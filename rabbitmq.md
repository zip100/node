* RabbitMQ是一个消息代理，一个消息系统的媒介，提供了一个通用的消息发送及接收平台，并且能够保障消息传输过程中的安全。使用erlang语言开发，开源，在易用性、扩展性、高可用性等方面表现不俗

## 技术亮点

* 可靠性——RabbitMQ提供了多种技术可以让你在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制。

* 灵活的路由——消息在到达队列前是通过交换机进行路由的。RabbitMQ为典型的路由逻辑提供了多种内置交换机类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做RabbitMQ的插件来使用。
* 集群——在相同局域网中的多个RabbitMQ服务器可以聚合在一起，作为一个独立的逻辑代理来使用。
* 联合——对于服务器来说，它比集群需要更多的松散和非可靠链接。为此RabbitMQ提供了联合模型。
* 高可用的队列——在同一个集群里，队列可以被镜像到多个机器中，以确保当其中某些硬件出现故障后，你的消息仍然安全。
* 多协议——RabbitMQ 支持多种消息协议的消息传递。
* 广泛的客户端——只要是你能想到的编程语言几乎都有与其相适配的RabbitMQ客户端。
* 可视化管理工具——RabbitMQ附带了一个易于使用的可视化管理工具，它可以帮助你监控消息代理的每一个环节。
* 追踪——如果你的消息系统有异常行为，RabbitMQ还提供了追踪的支持，让你能够发现问题所在。
* 插件系统——RabbitMQ附带了各种各样的插件来对自己进行扩展。你甚至也可以写自己的插件来使用。

### 专业术语

* Broker：简单来说就是消息队列服务器实体。
* Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。
* Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
* Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
* Routing Key：路由关键字，exchange根据这个关键字进行消息投递。
* vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
* producer：消息生产者，就是投递消息的程序。
* consumer：消息消费者，就是接受消息的程序。
* connection：连接，就是一个位于客户端和Broker之间的TCP连接
* channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。
* Message：由Header和Body组成，Header是由生产者添加的各种属性的集合，包括Message是否被持久化、由哪个Message Queue接受、优先级是多少等。而Body是真正需要传输的消息内容。

### 消息队列的使用过程大概如下：

（1）客户端连接到消息队列服务器，打开一个channel。

（2）客户端声明一个exchange，并设置相关属性。

（3）客户端声明一个queue，并设置相关属性。

（4）客户端使用routing key，在exchange和queue之间建立好绑定关系。

（5）客户端投递消息到exchange。

exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。

exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为"abc"，那么客户端提交的消息，只有设置了key为"abc"的才会投递到队列。对key进行模式匹配后进行投递的叫做Topic交换机，符号"\#"匹配一个或多个词，符号"\*"匹配正好一个词。例如"abc.\#"匹配"abc.def.ghi"，"abc.\*"只匹配"abc.def"。还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。

RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会选择持久化。消息队列持久化包括3个部分：

（1）exchange持久化，在声明时指定durable =&gt; 1

（2）queue持久化，在声明时指定durable =&gt; 1

（3）消息持久化，在投递时指定delivery\_mode =&gt; 2（1是非持久化）

如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。



