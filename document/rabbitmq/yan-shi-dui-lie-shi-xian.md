# 使用RabbitMQ实现延迟任务

---

* 场景一：物联网系统经常会遇到向终端下发命令，如果命令一段时间没有应答，就需要设置成超时。
* 场景二：订单下单之后30分钟后，如果用户没有付钱，则系统自动取消订单。

> 上述类似的需求是我们经常会遇见的问题。最常用的方法是定期轮训数据库，设置状态。在数据量小的时候并没有什么大的问题，但是数据量一大轮训数据库的方式就会变得特别耗资源。当面对千万级、上亿级数据量时，本身写入的IO就比较高，导致长时间查询或者根本就查不出来，更别说分库分表以后了。除此之外，还有优先级队列，基于优先级队列的JDK延迟队列，时间轮等方式。但如果系统的架构中本身就有RabbitMQ的话，那么选择RabbitMQ来实现类似的功能也是一种选择。

使用RabbitMQ来实现延迟任务必须先了解RabbitMQ的两个概念：消息的TTL和死信Exchange，通过这两者的组合来实现上述需求

* ### 消息的TTL（Time To Live）

消息的TTL就是消息的存活时间。RabbitMQ可以对队列和消息分别设置TTL。对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的TTL，因为它才是实现延迟任务的关键。

* ### 死信交换机 DLE（Dead Letter Exchanges）
* 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。

* 上面的消息的TTL到了，消息过期了。

* 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。

> Dead Letter Exchange其实就是一种普通的exchange，和创建其他exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。



![](/assets/WX20180801-143518.png)



具体实现步骤，就是新建一个队列，给队列设置一个TTL，但是不要来消费这个队列，业务消息投递到这个队列之后就就会因为到达TTL指定时间知乎没被消费就被投递到死信交换机，然后再从死信交换机再投递到一个正常消费的队列里面，从而达到延迟执行的效果。

1. 新建延时队列，并设定延时队列的TTL和DLE

```
// 指定需要投递的DLE名称
x-dead-letter-exchange:    delay.exchange
// 队列长度积压消息达到上限之后会被投递到DLE
x-max-length:    65535
// 消息的有效时间有效时间内没被消费也投递的哦DLE
x-message-ttl:    5000
```

2.新建延时交换机，需要延迟的消息 publish 到此交换机，并投递到上一步建的延时队列

3.新建 delay.exchange 用来消费消息

